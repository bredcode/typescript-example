### 문제

앞에서는 Cage<T> 같은 클래스에 제네릭을 적용해봤습니다.  
이번에는 함수에도 제네릭을 적용해봅시다.

우리가 만들려는 함수는:

- 여러 마리의 동물을 한꺼번에 받아서(Animal[] 또는 Dog[], Cat[])
- 배열로 받은 동물에 대해 다음과 같이 출력해봅시다.
  ```ts
  console.log(`이름: ${name} 나이: ${age} 소리: ${speak}`);
  ```

### 요구사항

- Animal Class를 `abstract class Animal`로 만듭니다.
- 추상 클래스에 `abstract speak(): void;`를 추가합니다.
- speakAll 함수를 만듭니다.
  - 제네릭을 이용하고 Animal만 받도록 작업합니다.
  - 인자명은 animals, 타입은 제네릭을 사용한 배열 타입입니다.
  - 리턴 타입은 void입니다.

```ts
//
// speakAll 함수 작성
//

abstract class Animal {
  constructor(public name: string, public age: number) {}

  describe(): string {
    return `이름: ${this.name}, 나이: ${this.age}`;
  }

  abstract speak(): void;
}

class Dog extends Animal {
  speak(): string {
    return "멍멍!";
  }
}

class Cat extends Animal {
  speak(): string {
    return "야옹~";
  }
}

class Cage<T extends Animal> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  getAll(): T[] {
    return this.items;
  }
}

const dogCage2 = new Cage<Dog>();
dogCage2.add(new Dog("Choco", 3));
console.log(dogCage2.getAll().map((d) => d.describe()));

const catCage2 = new Cage<Cat>();
catCage2.add(new Cat("Nabi", 1));
console.log(catCage2.getAll().map((c) => c.describe()));

// "이름: Bori 나이: 2 소리: 멍멍!"
// "이름: Nabi 나이: 1 소리: 야옹~"
// "이름: Choco 나이: 3 소리: 멍멍!"
speakAll([new Dog("Bori", 2), new Cat("Nabi", 1), new Dog("Choco", 3)]);
```
