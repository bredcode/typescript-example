### 문제

앞에서 만든 Cage<T>는 제네릭이라서 사실 아무 타입(number, string, 객체 등 무엇이든) 다 들어갈 수 있습니다.

하지만 우리의 목표는 "동물 전용 우리"입니다.  
즉, Animal을 상속받은 타입(예: Dog, Cat)만 들어가야 안전합니다.

그래서 이번엔 제네릭에 조건(Constraint)을 걸어보고자 합니다.
`class Cage<T extends Animal>` 형태로 만들면, 이제 `T는 반드시 Animal의 자식 클래스`여야 합니다.

### 요구사항

- Cage를 `class Cage<T extends Animal>`로 만듭니다.

- 이제 number, string 같은 건 컴파일 단계에서 막히도록 합니다.

  - Dog 전용 우리가 가능하고 ✔️
  - Cat 전용 우리가 가능하고 ✔️
  - number 같은 건 ❌

```ts
class Animal {
  constructor(public name: string, public age: number) {}

  describe(): string {
    return `이름: ${this.name}, 나이: ${this.age}`;
  }
}

class Dog extends Animal {
  speak(): string {
    return "멍멍!";
  }
}

class Cat extends Animal {
  speak(): string {
    return "야옹~";
  }
}

// 아래 Cage를 Animal만 받을 수 있게 수정
class Cage<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  getAll(): T[] {
    return this.items;
  }
}

const dogCage2 = new Cage<Dog>();
dogCage2.add(new Dog("Choco", 3));

// ["이름: Choco, 나이: 3"]
console.log(dogCage2.getAll().map((d) => d.describe()));

const catCage2 = new Cage<Cat>();
catCage2.add(new Cat("Nabi", 1));

// ["이름: Nabi, 나이: 1"]
console.log(catCage2.getAll().map((c) => c.describe()));
```
